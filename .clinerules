# Project Intelligence (.clinerules)

## Memory Bank Management Rules

### Reading Protocol
1. **Continuous Monitoring**
   - Memory Bank files and AGENTS.md must be read at the start of EVERY task
   - Files must be re-read when changes are detected
   - Changes in one file may affect others

2. **Reading Order**
   - AGENTS.md (repository context/instructions)
   - projectbrief.md (foundation)
   - productContext.md (purpose)
   - systemPatterns.md (architecture)
   - techContext.md (implementation)
   - activeContext.md (current state)
   - progress.md (status)

### Writing Protocol
1. **Update Triggers**
   - New patterns discovered
   - System changes detected
   - Process improvements identified
   - Documentation gaps found

2. **Update Process**
   - Update relevant Memory Bank file first
   - Cross-reference in other affected files
   - Document rationale in .clinerules
   - Verify markdown-lint compliance

## Project Patterns

### Setup Rules
1. **Script-Driven Changes**
   - All changes must use scripts in `scripts/` directory
   - No manual file/folder creation allowed
   - Scripts must be idempotent
   - Scripts must include existence checks

2. **Documentation Requirements**
   - README.md must be updated before implementation
   - All files must be markdown-lint compliant
   - Changes must be documented across Memory Bank
   - Cross-references must be maintained

### File Structure
```
/
├── .github/
├── .vscode/
├── memory-bank/
│   ├── projectbrief.md
│   ├── productContext.md
│   ├── systemPatterns.md
│   ├── techContext.md
│   ├── activeContext.md
│   └── progress.md
├── scripts/
│   └── setup_project.sh
├── .gitignore
├── AGENTS.md
├── .clinerules
└── README.md
```

## Learning Journal

### Pattern Recognition
- Memory Bank files are interconnected
- Changes must be propagated across files
- Documentation must precede implementation
- Script-driven changes ensure consistency

### Process Evolution
1. Read ALL Memory Bank files first
2. Plan changes across affected files
3. Update documentation before implementation
4. Use scripts for all changes
5. Verify compliance and cross-references

### Known Challenges
- Maintaining cross-file consistency
- Ensuring complete documentation coverage
- Following strict script-driven approach
- Keeping all files markdown-lint compliant

## Self-Regulation Protocols

### Verification Steps
1. Check Memory Bank files for updates
2. Verify script-driven changes
3. Validate markdown-lint compliance
4. Confirm cross-references
5. Test documentation completeness

## Pattern Examples and Implementation Guidance

### Example: Script-Driven Directory Creation
- **Pattern:** All directories must be created via scripts in `scripts/`.
- **Implementation:**  
  - Use `mkdir -p` in shell scripts.
  - Always check if the directory exists before creation.
  - Example:
    ```sh
    [ -d "./memory-bank" ] || mkdir ./memory-bank
    ```
- **Cross-reference:** Update README.md and Memory Bank files to reflect new directories.

### Example: Markdown-Lint Compliance
- **Pattern:** All markdown files must pass strict linting.
- **Implementation:**  
  - Use markdownlint CLI or VSCode extension.
  - Run lint checks before committing documentation.
- **Cross-reference:** Document linting requirements in README.md.

### Example: Change Propagation
- **Pattern:** Changes in one Memory Bank file may require updates in others.
- **Implementation:**  
  - After updating a file, review related files for consistency.
  - Document rationale for cross-file changes in .clinerules.

---

> This .clinerules file is a living document that evolves with the project.
> It must be updated whenever new patterns or rules are discovered.
> All agents must read and follow these rules for consistent operation.
